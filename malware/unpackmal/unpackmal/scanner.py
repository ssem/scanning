import re
from unpackmal import pefile

class Scanner:
    def signature(self, binary, signatures):
        signatures = SignatureDatabase(signatures)
        pe = pefile.PE(binary)
        return signatures.match(pe, True, False)

    def is_packed(self, binary):
        pe = pefile.PE(binary)
        compressed = 0
        for section in pe.sections:
            entropy = section.get_entropy()
            if entropy > 7.4:
                compressed += len(section.get_data())
        if (float(compressed) / len(pe.trim())) > .2:
            return True
        return False

class SignatureDatabase:
    def __init__(self, filename=None, data=None):
        self.signature_tree_eponly_true = {}
        self.signature_count_eponly_true = 0
        self.signature_tree_eponly_false = {}
        self.signature_count_eponly_false = 0
        self.signature_tree_section_start = {}
        self.signature_count_section_start = 0
        self.max_depth = 0
        self.__load(filename=filename)

    def match(self, pe, ep_only, section_start_only):
        try :
            data = pe.get_memory_mapped_image()
        except Exception, excp :
            raise
        signatures = self.signature_tree_eponly_true
        ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
        scan_addresses = [ep]
        matches = []
        for idx in scan_addresses:
            result = self.__match_signature_tree(
                signatures,
                data[idx:idx+self.max_depth])
            if result:
                matches.append( (idx, result) )
        if matches:
            return matches[0][1][0][0]

    def __match_signature_tree(self, signature_tree, data, depth = 0):
        matched_names = list ()
        match = signature_tree
        for idx, byte in enumerate ( [ord (b) for b in data] ):
            if match is None :
                break
            match_next = match.get(byte, None)
            if None in match.values():
                names = list()
                for item in match.items():
                    if item[1] is None :
                        names.append (item[0])
                matched_names.append(names)
            if match.has_key ('??') :
                match_tree_alternate = match.get ('??', None)
                data_remaining = data[idx + 1 :]
                if data_remaining:
                    matched_names.extend(
                        self.__match_signature_tree(
                            match_tree_alternate, data_remaining, idx+depth+1))
            match = match_next
        if match is not None and None in match.values():
            names = list()
            for item in match.items() :
                if item[1] is None:
                    names.append(item[0])
            matched_names.append(names)
        return matched_names

    def __load(self, filename):
        sig_f = file( filename, 'rt' )
        sig_data = sig_f.read()
        sig_f.close()
        if not sig_data:
            exit('\n\tEmpty Signature File\n')
        regex = '\[(.*?)\]\s+?signature\s*=\s*(.*?)(\s+\?\?)'
        regex += '*\s*ep_only\s*=\s*(\w+)(?:\s*section_start_only\s'
        regex += '*=\s*(\w+)|)'
        parse_sig = re.compile(regex, re.S)
        matches = parse_sig.findall(sig_data)

        def to_byte(value) :
            if value == '??' or value == '?0' :
                return value
            return int (value, 16)

        for packer_name, sig, wild, eo, section_start_only in matches:
            ep_only = eo.strip().lower()
            signature = sig.replace('\\n', '').strip()
            signature_bytes = [to_byte(b) for b in signature.split()]
            if ep_only == 'true':
                ep_only = True
            else:
                ep_only = False
            if section_start_only == 'true':
                section_start_only = True
            else:
                section_start_only = False
            depth = 0
            if section_start_only is True:
                tree = self.signature_tree_section_start
                self.signature_count_section_start += 1
            else:
                if ep_only is True :
                    tree = self.signature_tree_eponly_true
                    self.signature_count_eponly_true += 1
                else :
                    tree = self.signature_tree_eponly_false
                    self.signature_count_eponly_false += 1
            for idx, byte in enumerate (signature_bytes) :
                if idx+1 == len(signature_bytes):
                    tree[byte] = tree.get( byte, dict() )
                    tree[byte][packer_name] = None
                else :
                    tree[byte] = tree.get ( byte, dict() )
                tree = tree[byte]
                depth += 1
            if depth > self.max_depth:
                self.max_depth = depth
